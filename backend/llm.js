import { Groq } from 'groq-sdk';
import dotenv from 'dotenv';
import { create_element_prompt } from './prompts.js';
import { ElementCache } from './schema.js';
import { textToSpeech } from './tts.js';
import { getElementName } from './languages.js';
dotenv.config();

const groq = new Groq();

// Helper function to get cached element combination
async function getCachedElement(element1, element2, languageCode = 'en-US') {
  try {
    // Use English element names directly for consistent cache lookup
    // Normalize case and order to ensure consistent lookup
    const [first, second] = [element1.toLowerCase(), element2.toLowerCase()].sort();
    
    const cached = await ElementCache.findOne({
      element1: first,
      element2: second,
      languageCode: languageCode
    });
    
    return cached ? cached.result : null;
  } catch (error) {
    console.error('Error retrieving cached element:', error);
    return null;
  }
}

// Helper function to cache element combination
async function cacheElement(element1, element2, result, languageCode = 'en-US') {
  try {
    // Use English element names directly for consistent cache storage
    // Normalize case and order to ensure consistent caching
    const [first, second] = [element1.toLowerCase(), element2.toLowerCase()].sort();
    
    // Generate audio for the new element if not already present
    if (!result.audio_b64) {
      try {
        console.log(`Generating TTS for "${result.element}" in ${languageCode}`);
        result.audio_b64 = await textToSpeech(languageCode, result.element);
      } catch (ttsError) {
        console.error('Error generating TTS audio:', ttsError);
        // Continue without audio if TTS fails
        result.audio_b64 = null;
      }
    }
    
    const cacheEntry = new ElementCache({
      element1: first,
      element2: second,
      result: result,
      languageCode: languageCode
    });
    
    await cacheEntry.save();
    console.log(`Cached combination: ${first} + ${second} = ${result.element} (with audio: ${result.audio_b64 ? 'yes' : 'no'})`);
  } catch (error) {
    console.error('Error caching element:', error);
  }
}

async function create_element(element1, element2, languageCode = 'en-US') {
  try {
    // First, check if we have this combination cached for this language
    const cachedResult = await getCachedElement(element1, element2, languageCode);
    if (cachedResult) {
      console.log(`Cache hit: ${element1} + ${element2} = ${cachedResult.element} (${languageCode})`);
      
      // Generate audio if not present for the cached result
      if (!cachedResult.audio_b64) {
        try {
          console.log(`Generating missing TTS for cached "${cachedResult.element}" in ${languageCode}`);
          cachedResult.audio_b64 = await textToSpeech(languageCode, cachedResult.element);
        } catch (ttsError) {
          console.error('Error generating TTS for cached element:', ttsError);
          cachedResult.audio_b64 = null;
        }
      }
      
      return cachedResult;
    }

    console.log(`Cache miss: ${element1} + ${element2}, calling LLM...`);
    
    // If not cached, make the LLM call
    const chatCompletion = await groq.chat.completions.create({
      "messages": [
        {
          "role": "system",
          "content": `${create_element_prompt}\n\nCombine these two elements: ${element1} + ${element2}. Output the result in ${languageCode} language. 

IMPORTANT: Always include both "element" (in ${languageCode}) and "en_text" (in English) fields in your JSON response.

Example for Chinese: {"element": "Ëí∏Ê±Ω", "en_text": "Steam", "emoji": "üí®"}
Example for Spanish: {"element": "Vapor", "en_text": "Steam", "emoji": "üí®"}
Example for English: {"element": "Steam", "en_text": "Steam", "emoji": "üí®"}`
        },
        {
          "role": "user",
          "content": `${element1} + ${element2}`
        }
      ],
      "model": "openai/gpt-oss-20b",
      "temperature": 0,
      "max_completion_tokens": 1024,
      "top_p": 1,
      "stream": false,
      "reasoning_effort": "low",
      "stop": null
    });

    const response = chatCompletion.choices[0]?.message?.content;
    
    // Parse the JSON response
    try {
      const parsed = JSON.parse(response);
      
      // Add en_text field if not present (for new LLM-generated elements)
      if (!parsed.en_text) {
        // For new elements generated by LLM, we need to set en_text to English
        // Since the LLM might generate in another language, we should ask it to provide English name
        // For now, if languageCode is not English, we'll need the English equivalent
        if (languageCode === 'en-US') {
          parsed.en_text = parsed.element; // Already in English
        } else {
          // For non-English, the element name should be translated but en_text should be English
          // We need to generate English version or use the element as placeholder
          parsed.en_text = parsed.element; // Temporary - should be English translation
        }
      }
      
      // Cache the successful result
      await cacheElement(element1, element2, parsed, languageCode);
      
      return parsed;
    } catch (parseError) {
      // Fallback if JSON parsing fails
      console.error('Failed to parse JSON response:', response);
      const fallback = { element: "trash", en_text: "trash", emoji: "‚ùì" };
      
      // Cache the fallback result to avoid repeated failures
      await cacheElement(element1, element2, fallback, languageCode);
      
      return fallback;
    }
    
  } catch (error) {
    console.error('Error creating element:', error);
    const errorResult = { element: "Error", en_text: "Error", emoji: "‚ö†Ô∏è" };
    
    // Don't cache error results as they might be temporary issues
    return errorResult;
  }
}

export { create_element };

